# 연습 문제 2 - 부분집합 합 문제 구현하기
'''
3
19 6 16 19 15 16 8 13 16 10
-20 -6 -13 3 -19 -9 19 -3 9 4
7 7 19 1 -18 5 -9 -11 19 18

#1 0
#2 1
#3 1
'''
# 1. 10개의 정수를 input받는다
# 2. 부분집합의 합이 0이 되는 것이 존재 하는지
# 3조

## 접근 방식

arr = [1, 2, 3, 4, 5]
N = len(arr)
'''
arr의 부분집합은 arr 안의 요소들 하나하나에 대해 포함되거나 포함되지 않거나
단 두가지 경우의 수의 조합으로 만들어지므로 총 조합의 수는 2 ** N 입니다.

비트 연산에 쓰이는 << 연산자는 연산자 (앞의 수의 이진수) 뒤에 뒤의 수만큼의 0(2진수이므로 자릿수)을 더한다는 말입니다.
예를 들어, 1<<5 는 이진수 100000 즉 십진수 32를 의미합니다.
그러므로 원소가 N개인 집합에서 가능한 경우의 수는 1 << N 으로 표현이 가능합니다.
'''

all_subsets = []    # 모든 부분집합입니다.
for i in range(1 << N):   # 앞서 말한대로 원소가 N개인 집합에서 가능한 부분집합만큼 반복을 하고 (1<<N이 아니라 2**N도 무방할 것입니다.)
    subset = []     # i의 범위에 따른 부분집합들입니다.
    for j in range(N):  # 0(공집합), 1, 2, 3,...,N 에 해당하는 j의 반복문을 설정합니다.
        if i & (1 << j):  # i의 최고 자릿수는 항상 1이어야 하고, (1<<j가 아니라 2**j도 무방할 것입니다.)
            #             그 미만의 자릿수들에 대해 모든 경우의 수(i만 1이고 이하 자릿수 모두 0인 경우 포함)를 추출합니다.
            #             하단에 도식화 해두겠습니다.
            subset.append(arr[j])
    all_subsets.append(subset)

print(len(all_subsets), all_subsets)    # 모든 부분집합의 수가 32개임과 각각의 부분집합을 확인할 수 있습니다.

'''
경우의 수가 이진수 100000 개일 때,
모든 경우의 수는
(전자의 수가 i일때, i보다 자릿수가 작은 j가 가지는 부분집합을 나타냈습니다. 이유는 상단의 코드에서 i와 j 범위를 보시면 됩니다.)
1 => 0
10 => 1 
100 => 10 
       11 
1000 => 100 
        101
        110 111 
10000 => 1000
         1001
         1010 1011
         1100 1101 1110 1111
100000 => 10000
          10001
          10010 10011
          10100 10101 10110 10111
          11000 11001 11010 11011 11100 11101 11110 11111

이므로 총 32개임을 확인할 수 있습니다.
'''