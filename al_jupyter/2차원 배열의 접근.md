# 인풋

```python
"""
1. input을 이용해 자료 입력 받기
"""

# 1.1 정수 한 개 입력 받기
N = int(input())

# 1.2 정수 형태로 여러개 입력 받기
A, B = map(int, input().split())

# 1.3 정수 형태로 일차원 리스트로 입력 받기
numbers = list(map(int, input().split()))

numbers = [map(int, input().split())] # 이건 안돼요
print(numbers) # map Object ...


# 1.4 띄어쓰기가 없는 형태의 정수를 리스트로 입력받기
numbers = list(input()) # ['1', '2', '3']
numbers = list(map(int, list(input())))

# 1.5 이차원 리스트 입력 받기
matrix = []
for _ in range(N):
    row = list(map(int, input().split()))
    matrix.append(row)

print([ x for x in range(N)]) 
matrix = [list(map(int, input().split()) for _ in range(N)]
```





# 2차원 배열의 접근

- IM 시험의 keypoint
- ‘행 우선 순회’를 다른 것 보다 우선적으로 익히기

```python
# 1부터 9까지 출력하기

num_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

for r in range(len(num_list)):
    for c in range(len(num_list[0])):
        print(f'{num_list[r][c]}', end=' ')
```

## 행/열 우선 순회

```python
# 행의 길이 
N = len(arr)

# 열의 길이 -> 인덱스를 주의해야 함
M = len(arr[0])
```

- idx `i` 는 행을 순회하는 아이 / idx `j` 는 열을 순회하는 아이
- 가장 바깥의 for문의 idx가 `i` / 한칸 안쪽의 `for`문 idx가 `j`
- 식으로 스스로의 규칙을 만들어야 헷갈리지 않음
- 많은 사람들이 행은 `i`, 열은 `j` 로 적고있으나, 
본인이 헷갈리지않는 방법을 찾아서 사용해도 무관

### 행 우선 순회

```python
# i 행의 좌표
# j 열의 좌표

for i in range(N):
   for j int range(M):
        print(arr[i][j])
```

### 열 우선 순회

- 크기가 일정하지 않을 경우는 조건으로 제한을 걸어야 함
- 리스트의 길이는 매번 판단

```python
# i 행의 좌표
# j 열의 좌표

for j in range(M):
    for i in range(N):
        print(arr[i][j])
```

### 역-행 우선순회

```python
for i in range(N):
    # index 0까지(-1 + 1)
    for j in range(M-1, -1, -1):
        print(arr[i][j])
```

### 역-열 우선 순회

```python
for i in range(M-1, -1, -1):
    for j in range(N):
        print(arr[j][i])
```

### 지그재그

```python
for i in range(N):
    for j in range(M):
        # (i % 2)는 0+짝 vs 홀수 열에 대한 구분
				# 애초에 0 + 짝수열은 수행되지 않음
        print(arr[i][j + (M-1-2*j) * (i%2)])
```

## 델타

- 델타를 쓰지 않고 구현하기
  
    ```python
    # 5의 입장에서, 상 하 좌 우에 있는 숫자를 출력해보세요.
    
    from pprint import pprint
    
    num_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    pprint(num_list, indent=4, width=14) # pprint는 선택사항
    
    for r in range(len(num_list)):
        for c in range(len(num_list[0])):
            if num_list[r][c] == 5:
                print(num_list[r - 1][c])  # 상
                print(num_list[r + 1][c])  # 하
                print(num_list[r][c - 1])  # 좌
                print(num_list[r][c + 1])  # 우
    ```
    
- 델타를 사용해서 구현하기
  
    ```python
    # 5의 입장에서, 상 하 좌 우에 있는 숫자를 출력해보세요.
    from pprint import pprint
    
    num_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    pprint(num_list, indent=4, width=14)
    
    for r in range(len(num_list)):
        for c in range(len(num_list[0])):
            if num_list[r][c] == 5:
                d_row = [-1, 1, 0, 0] # 상 하 좌 우
                d_col = [0, 0, -1, 1]
                for d in range(4):
                    row = r + d_row[d]
                    col = c + d_col[d]
                    print(num_list[row][col], end=' ')
    ```
    
- 방향의 순서가 중요하지 않을 경우에는 `d_row(dy)`, `d_col(dx)` 적당히 적어도 무관
  
    ```python
    """
    # x -> 가로 인덱스 변경 (또는 r)
    # y -> 세로 인덱스 변경 (또는 c)
    """
    
    dx = [-1, 1, 0, 0] # 상 하 좌 우
    dy = [0, 0, -1, 1] 
    
    # 상하좌우 -> 아래와 같이 2차원 배열로 나타내도 괜찮음
    dxy = [[-1, 0], [1, 0], [0, -1], [0, 1]]
    
    for d in range(4):
        # next row & next column -> 이동 이후에 새로운 위치
        nx = x + dx[d]
        ny = y + dy[d]
    ```
    

만약 현재 위치를 아래와 같이 변경하면? → 에러가 나지 않음 왜? → 파이썬은 음수 인덱스 지원

- 때문에 명확하게 벽을 넘어가지 않게 하는 것이 중요
  
    ```python
    x = 0
    y = 1
    ```
    

벽의 제한을 두자

```python
# 1. 벽을 넘어가는 경우 아무 것도 하지 않기

for d in range(4):
    # next row & next column -> 이동 이후에 새로운 위치
    nx = x + dx[d]
    ny = y + dy[d]

    **# map을 벗어나는 경우에 아무것도 하지 않기**
    if nx < 0 or nx >= N or ny < 0 or ny >= N: 
        continue
    print(arr[nx][ny]) # 2 8 4 6 -> 상하좌우
```

```python
#2. 반대로 벽을 넘어가지 않는 경우만 수행하기

for d in range(4):
    # next row & next column -> 이동 이후에 새로운 위치
    nx = x + dx[d]
    ny = y + dy[d]

		**# 아래처럼 가능한 경우만 포함 시키기
    if 0 <= nx < N and 0 <= ny < N:
        print(arr[nx][ny])**

    print(arr[nx][ny]) # 2 8 4 6 -> 상하좌우
```

---

## 2차원 배열의 활용

### 전치행렬

```python
lst = [[1,2,3],[4,5,6],[7,8,9]]
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b244e4fa-53aa-4c6c-b49b-e1e314732ac5/Untitled.png)

- 전치
  
    ```python
    # 1
    
    for i in range(3):
        for j in range(3):
            if i < j:
                lst[i][j], lst[j][i] = lst[j][i], lst[i][j]
    ```
    
    ```python
    # 2
    
    lst = list(map(list, zip(*lst)))
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c534c2b6-36fc-4798-85c6-b33e37512b0a/Untitled.png)
    
- 점대칭
  
    ```python
    lst = list(map(list, zip(*lst[::-1])))[::-1]
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ecfbe262-7dbd-4dce-ba96-10960ee9963e/Untitled.png)
    
- 오른쪽 90도 회전
  
    ```python
    lst = list(map(list, zip(*lst[::-1])))
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/df91ee08-c3bc-41de-b793-3a6c8c795c86/Untitled.png)
    
- 왼쪽으로 90도 회전
  
    ```python
    lst = list(map(list, zip(*lst)))[::-1]
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a3a55200-dbd0-45a9-a93a-4d357785def7/Untitled.png)