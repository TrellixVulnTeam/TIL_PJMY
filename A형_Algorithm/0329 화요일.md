![image-20220329090922788](C:%5CUsers%5Cstar3%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220329090922788.png)



## 5188 최소합

``` python
T = int(input())

# 길찾기 dfs
def road(x, y, total):
    global result
    # 만약 도착했다면
    if x == N-1 and y == N-1:
        # 마지막 도착점것을 더해주고
        total += arr[y][x]
        # 최소값을 갱신해준다.
        if total < result:
            result = total
            return
    # 시간을 줄이기위해 과정중에 현재 최소값 보다 크면 계산 가치 x
    if total > result:
        return

    dx = [1, 0]
    dy = [0, 1]

    # 모드를 돌아다니면서 검색
    for i in range(2):
        # 다음 좌표 둘러보기
        cx = x + dx[i]
        cy = y + dy[i]
        # 만약 범위 넘어가면 패스
        if x > N-1 or y > N-1:
            continue
        # 방문한 적이 없다면
        if not visited[y][x]:
            # 방문도장 찍고
            visited[y][x] = 1
            # 다음 좌표 보면서 total 값도 같이 넘겨줌
            road(cx, cy, total + arr[y][x])
            # 돌아왔다면 방문도장 지워주기
            visited[y][x] = 0

for tc in range(1, T+1):
    N = int(input())
    arr = [list(map(int,input().split()))for _ in range(N)]
    # 결괏값은 최대값으로 설정
    result = 10 * 2 * N
    # 방문 검사를 위한 배열
    visited = [[0 for _ in range(N)]for _ in range(N)]
    # 길찾아보자 - 함수호출
    road(0, 0, 0)


    print("#{} {}".format(tc, result))
```



![image-20220329175714166](0329%20%ED%99%94%EC%9A%94%EC%9D%BC.assets/image-20220329175714166.png)



![image-20220329180942920](0329%20%ED%99%94%EC%9A%94%EC%9D%BC.assets/image-20220329180942920.png)



![image-20220329182734822](0329%20%ED%99%94%EC%9A%94%EC%9D%BC.assets/image-20220329182734822.png)

 

![image-20220329182745196](0329%20%ED%99%94%EC%9A%94%EC%9D%BC.assets/image-20220329182745196.png)





## 5189 전자카트 (완탐의 기본기 문제..?)

![image-20220329130902233](0329%20%ED%99%94%EC%9A%94%EC%9D%BC.assets/image-20220329130902233.png)



인접 행렬 저장 방식

![image-20220329131051786](0329%20%ED%99%94%EC%9A%94%EC%9D%BC.assets/image-20220329131051786.png)

`주석`

```python
# input(이차원 리스트로)
# result, min_count (결과를 저장할 변수)
# visited 리스트 두기 - 1차원 (노드 1,2,3각각 방문1 방문X0 이렇게 두면됨)

# dfs, bfs, search()
# search() 구현하기
	# s = 파라미터를 받아서 어디서 출발하는지 적고
	# global 변수로 지금 내가 가지고 있는 가중치, 현재 가장 작은 가중치 비교
    # 지금 내가 가지고 있는 가중치 > 현재 가장 작은 가중치라면 가지치기(백트레킹)
    
    # 그렇지 않다면
    	# 반복문이 들어감 for문 (모든 경우를 돌게 해줌)
        for elem in elems:   #내가 아닌 elems 모든 방을 돌면서 재귀호출 
        	#뭔가 A에 조작을 하고
        	#재귀호출
        	#조작한 A를 다시 돌려놓음

```

![image-20220329132413016](0329%20%ED%99%94%EC%9A%94%EC%9D%BC.assets/image-20220329132413016.png)

* 재귀는 1번 다음에 2번가보세요 3번가보세요 

![image-20220329132655109](0329%20%ED%99%94%EC%9A%94%EC%9D%BC.assets/image-20220329132655109.png)



![image-20220329133058405](0329%20%ED%99%94%EC%9A%94%EC%9D%BC.assets/image-20220329133058405.png)



![image-20220329133213629](0329%20%ED%99%94%EC%9A%94%EC%9D%BC.assets/image-20220329133213629.png)







---

전자카트

![image-20220329183559129](0329%20%ED%99%94%EC%9A%94%EC%9D%BC.assets/image-20220329183559129.png)



cnt =모든방을 다 방문했다면,

![image-20220329184301657](0329%20%ED%99%94%EC%9A%94%EC%9D%BC.assets/image-20220329184301657.png)







근데 상위 함수로 callback되면서 visited를 다 0으로 만들고 놨는데 

예를 들어서 s 가 4-> 3으로 다시 콜백됐을 때

for문이  





```python
import sys

sys.stdin = open('input.txt')


def dfs(s, cnt, acc):
    global result

    if acc >= result:
        return

    if cnt == N - 1:
        acc += arr[s][0]
        result = min(result, acc)

    else:
        for w in range(N):
            if s != w and not visited[w]:
                visited[w] = 1
                dfs(w, cnt + 1, acc + arr[s][w])
                visited[w] = 0

    return


# 인풋
T = int(input())
for tc in range(1, T + 1):
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]
    visited = [0] * N
    result = 987654321

    dfs(0, 0, 0)
    print(f'#{tc} {result}')
```







## 5201 컨테이너 운반

```python
T = int(input())

for tc in range(1, T+1):
    N, M = map(int, input().split())
    weight = list(map(int, input().split()))
    capacity = list(map(int, input().split()))

    # 화물은 하나씩만 담을 수 있으므로 가장 큰 화물을 가장 큰 트럭에 담는것이 최고이다.

    # 이를 위해 무게와 용량을 큰순서대로 정렬해준다.
    sorted_weight = sorted(weight, reverse=True)
    sorted_capacity = sorted(capacity, reverse=True)
    # 결과값을 초기화 해준다. (트럭수만큼)
    result = [0 for _ in range(M)]

    # 화물들을 번갈아 가면서 넣어본다.
    for i in range(N):
        # 화물에 맞는 트럭을 검사한다.
        for j in range(M):
            # 만약 화물을 적재할 수 있을때
            if sorted_weight[i] <= sorted_capacity[j]:
                # 그 트럭에 아무것도 실려있지 않다면
                if not result[j]:
                    # 트럭에 적재를 한다.
                    result[j] = (sorted_weight[i])
                    # 그리고 이 짐은 이미 실렸기 때문에 break 하여 다음 짐을 본다.
                    break

    print("#{} {}".format(tc, sum(result)))
```



