# 컴퓨팅 사고력, 배열 , 완전 탐색

![image-20220324184530393](0324%20%EB%AA%A9%EC%9A%94%EC%9D%BC.assets/image-20220324184530393.png)



---

비율로 풀기

![image-20220324185614921](0324%20%EB%AA%A9%EC%9A%94%EC%9D%BC.assets/image-20220324185614921.png)

1을 만나면 1개수세기, 0 개수세고, 1개수, 0개수 

![image-20220324185702658](0324%20%EB%AA%A9%EC%9A%94%EC%9D%BC.assets/image-20220324185702658.png)







---







![image-20220324191905240](0324%20%EB%AA%A9%EC%9A%94%EC%9D%BC.assets/image-20220324191905240.png)



배열은 값을 담고 ~~~

연산은 ?

최악은 O(N) , 일반적으론 O(1)

맨뒤에 있으면 최악.

그나마 배열 장점 : 어떤 인덱스에 있는 값을 찾는건 상수시간이다.

![image-20220324195001829](0324%20%EB%AA%A9%EC%9A%94%EC%9D%BC.assets/image-20220324195001829.png)

동적배열

정적 배열이 좀 더 빠르긴 하는데, 시간복잡도에서는 별로 차이가 없다.

동적 배열은 메모리를 필요한 만큼 사용하지만, 

정적 100개 동적 100개라면 동적이 메모리를 더 많이 씀. (추가 됐을 때 늘어나고 줄어들게 하기 위해서 추가 메모리를 내부적으로 더 씀)

동적 배열도, O(1) 



삽입, 삭제가 자주 일어나면 ? `배열` 보다 효율적인 것을 찾아야함

- 이럴 때 `연결 리스트`를 쓰는 게 더 좋을 때가 있는 것임 (항상 x)



> 노드 : 정보를 담는 하나의 창구

* 하나의 노드는 하나의 데이터를 품고 있음
* 데이터의 하나의 단위

* 연결 리스트는 하나의 데이터를 담고 있는 노드가 있고, 노드끼리는 화살표로 연결되어있음

삽입/삭제의 최적화, 상수시간의 시간복잡도

* 연결 리스트에서 노드란 정보를 담는 하나의 창구로, 연결 리스트는 노드 간의 연속적인 (  연결  )로 구성되어 있습니다. 정의하는 방법에 따라 (    앞/뒤로  ) 이동할 수 있습니다.



* next 값을 null로 바꾸기
* 시간복잡도 O(n)
* next값만 바꿔주면됨. 
  * --> 삭제하는데 상수시간이 걸림, 넥스트 시간만 바꿔주면되니깐
  * 삽입할때도 상수시간 
* 



![image-20220324201420617](0324%20%EB%AA%A9%EC%9A%94%EC%9D%BC.assets/image-20220324201420617.png)

single linked list

삽입 : 끝/ 앞 / 중간 (순서 주의)

삭제 : 이전 노드를 생각하기 - 끝/ 앞 

![image-20220324204417532](0324%20%EB%AA%A9%EC%9A%94%EC%9D%BC.assets/image-20220324204417532.png)

