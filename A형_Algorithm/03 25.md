![image-20220325165151750](C:%5CUsers%5Cstar3%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220325165151750.png)





![image-20220325165308277](C:%5CUsers%5Cstar3%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220325165308277.png)

* 첫번째 케이스

![image-20220325165616921](03%2025.assets/image-20220325165616921.png)

입구를 그대로 두든, 입구를 증가시키든 같은 것임



![image-20220325171124512](03%2025.assets/image-20220325171124512.png)

![image-20220325171110318](03%2025.assets/image-20220325171110318.png)

![image-20220325171215457](03%2025.assets/image-20220325171215457.png)



```python

```







## 노드의 거리 

인풋은 4 6 까지 받기

![image-20220325173411008](03%2025.assets/image-20220325173411008.png)



### 데이터 저장 방식

1. 인접 행렬 (보통 이걸로 씀.. 귀찮으니깐...메모리 터지면 2번으로 풀기)
2. 인접 리스트 

![image-20220325173736292](03%2025.assets/image-20220325173736292.png)





무한히 도는것 : visited 를 만들어서 방지함 방문하면 1더해줌 안하면 0

![image-20220325174155974](03%2025.assets/image-20220325174155974.png)

![image-20220325174804559](03%2025.assets/image-20220325174804559.png)





![image-20220325175728617](03%2025.assets/image-20220325175728617.png)



![image-20220325180023275](03%2025.assets/image-20220325180023275.png)





1번부터 넣고 4번이 도착하는 곳임

bfs 돌리면 1번과 연결되어있는거 큐에다 넣어주세요

큐에서 하나 빼요

2번아 너 꼬리니 ? ㄴㄴ 그럼 2번과 연결되어 있는거 큐에 다 넣어주세요 

그다음 나오세요 

너 꼬리니? 

![image-20220325180422759](03%2025.assets/image-20220325180422759.png)





![image-20220325180841573](03%2025.assets/image-20220325180841573.png)

![image-20220325181002784](03%2025.assets/image-20220325181002784.png)

1이면 연결되어있다.

![image-20220325182014315](03%2025.assets/image-20220325182014315.png)







1을 출발하면서 비지티드 인덱스 1을 1로 바꿈

![image-20220325182139290](03%2025.assets/image-20220325182139290.png)



1 내보냄

![image-20220325182211808](03%2025.assets/image-20220325182211808.png)



3 4 를 Q에 넣고 비지티드에 2를 넣어줌

1에서 부터 3,4가와서 1ㅇ을 더해서 넣어줌 (2가 들어감)

![image-20220325182253529](03%2025.assets/image-20220325182253529.png)

3을 빼주고 3에서 넣을 수 있는 2, 1을 봄

1은 0이 아니니까 제외, 2에 3을 넣어줌 

![image-20220325182344291](03%2025.assets/image-20220325182344291.png)

4를 뺌, 1이랑 6이 연결되어있음

1은 방문, 6은 방문X

4는 2가 들어있고 6은 2+1해서 3번만에 옴

![image-20220325182433282](03%2025.assets/image-20220325182433282.png)



![image-20220325182448499](03%2025.assets/image-20220325182448499.png)



5까지 다 빠져나오면 큐 끝남과 동시에 while도 끝남

---





## 백준 1260 dfs, bfs





![image-20220325210630191](03%2025.assets/image-20220325210630191.png)





![image-20220325211037701](03%2025.assets/image-20220325211037701.png)



![image-20220325211606557](03%2025.assets/image-20220325211606557.png)

row 시작이고 col 도착 



---



> 다른 방법![image-20220325212432681](03%2025.assets/image-20220325212432681.png)

![image-20220325212422108](03%2025.assets/image-20220325212422108.png)







![image-20220325213123688](03%2025.assets/image-20220325213123688.png)







## BFS

![image-20220325214340511](03%2025.assets/image-20220325214340511.png)

![image-20220325214418711](03%2025.assets/image-20220325214418711.png)start , end가 계속 바뀜 

```python
# DFS BFS

import sys
from collections import deque

def dfs(n):
    visited[n] = True
    print(n, end=' ')
    for i in graph[n]:
        if not visited[i]:
            dfs(i)

def bfs(n):
    queue = deque([n])
    visited[n] = True
    while queue:
        V = queue.popleft()
        print(V, end=' ')
        for i in graph[V]:
            if not visited[i]:
                queue.append(i)
                visited[i] = True


input = sys.stdin.readline

N, M, V = map(int, input().split())
graph = [[] for _ in range(N+1)]
visited = [False for _ in range(N+1)]

for _ in range(M):
    s, e = map(int, input().split())
    graph[s].append(e)
    graph[e].append(s)

for i in range(1, N+1):
    graph[i].sort()

dfs(V)

print()
visited = [False for _ in range(N+1)]
bfs(V)
```

![image-20220325214953538](03%2025.assets/image-20220325214953538.png)





![image-20220325215551130](03%2025.assets/image-20220325215551130.png)



![image-20220325220902779](03%2025.assets/image-20220325220902779.png)

![image-20220325220910944](03%2025.assets/image-20220325220910944.png)

![image-20220325220919650](03%2025.assets/image-20220325220919650.png)

![image-20220325221011055](03%2025.assets/image-20220325221011055.png)

![image-20220325221316522](03%2025.assets/image-20220325221316522.png)

q = deque() 선언하고 그 뒤로는 리스트로 사용할 수 있음

method 찾아보면 앞뒤로 넣고빼기가능

![image-20220325222825958](03%2025.assets/image-20220325222825958.png)

미로찾기 문제







## 백준 미로 2178

```python
from collections import deque

# 가로 세로 크기 변수 가져오기
N, M = map(int, input().split())
# 미로를 matrix로 받아오기
matrix = [list(map(int, input())) for _ in range(N)]
# 미로에서 간 거리를 count 행렬에 표시
count = [[0 for _ in range(M)] for _ in range(N)]
# 미로에서 방문했으면 방문 처리 행렬
visited = [[False for _ in range(M)] for _ in range(N)]

# 방향 벡터
di = [0, 0, 1, -1]
dj = [1, -1, 0, 0]

# 시작지점을 queue에 담아서 표시
queue = deque([0, 0])
# 시작지점 방문 처리
visited[0][0] = True
# 시작지점을 거리 1로 보기
count[0][0] = 1

# bfs 시작
while queue:
    # bfs 시작을 꺼내기
    i, j = queue.popleft()

    # 종료 조건 도착지점을 만나면 while 더이상 돌지마
    if i == N-1 and j == M-1:
        break

    # 갈수있는 방향 체크하기 위해서 4방향 반복문
    for k in range(4):
        ni = i + di[k]
        nj = j + dj[k]
        # 범위를 넘지 않고 방문하지 않았으며 통로인 구역이면 if 조건에 성립
        if 0 <= ni < N and 0 <= nj < M and not visited[ni][nj] and matrix[ni][nj] == 1:
            # 갈 수 있는 곳이니까 queue에 담아주고
            # 방문처리
            # 한칸 진행했으니까 다음칸은 count += 1
            queue.append([ni, nj])
            visited[ni][nj] = True
            count[ni][nj] += count[i][j] + 1

# 시작지점을 1로 잡고 출발해서 -1을 해줌
print(count[N][M]-1)
```





![image-20220325224658702](03%2025.assets/image-20220325224658702.png)

![image-20220325225044552](03%2025.assets/image-20220325225044552.png)







![image-20220325225304077](03%2025.assets/image-20220325225304077.png)

BFS : 최단거리 찾기

DFS : 내가 찾은 것 중에서 최단 거리 찾기 + 백트레킹 요구

디저트카페 BFS로 못푸는 문제 

BFS로 풀림



