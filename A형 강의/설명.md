## 0325 



![image-20220407000954883](C:%5CUsers%5Cstar3%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220407000954883.png)

미로 끝을 찾는 것은 미로 입구~ 출구를 찾는 문제 : 둘 중 멀써도 된다. 깊이 우선 DFS가 주로 쓰임



이렇게 트리가 됨.

![image-20220407001453416](%EC%84%A4%EB%AA%85.assets/image-20220407001453416.png)![image-20220407001646073](%EC%84%A4%EB%AA%85.assets/image-20220407001646073.png)

같은 레벨에 있는 애들은 같은 처리

![image-20220407001741515](%EC%84%A4%EB%AA%85.assets/image-20220407001741515.png)

---

그래프의 한 종류가 트리고 트리중에 이진트리가 있음 (단방향 그래프)

![image-20220407003012212](%EC%84%A4%EB%AA%85.assets/image-20220407003012212.png)

![image-20220407012742326](%EC%84%A4%EB%AA%85.assets/image-20220407012742326.png)





![image-20220407003821533](%EC%84%A4%EB%AA%85.assets/image-20220407003821533.png)



``` python



```

![image-20220407004004918](%EC%84%A4%EB%AA%85.assets/image-20220407004004918.png)



stack

![image-20220407005545244](%EC%84%A4%EB%AA%85.assets/image-20220407005545244.png)



![image-20220407011602419](%EC%84%A4%EB%AA%85.assets/image-20220407011602419.png)

인접리스트

![image-20220407011137639](%EC%84%A4%EB%AA%85.assets/image-20220407011137639.png)





인접 행렬

![image-20220407011544471](%EC%84%A4%EB%AA%85.assets/image-20220407011544471.png)





![image-20220407012241345](%EC%84%A4%EB%AA%85.assets/image-20220407012241345.png)

``` python
def DFS(start_node):
    visited = []
    stack = [start_node]

    # 후입선출
    while stack:
        # 현재 바라보는 노드(tmp): 스택의 맨 뒤
        # 중복을 피해서 tmp를 방문 기록
        # tmp랑 '연결이 된 노드들'을 스택에 더해줘요
        # 스택을 다시 꺼내가면서 스택이 다 빌때까지 순회를 해요.
        tmp = stack.pop()
        if tmp not in visited:
            visited.append(tmp)

            for idx in range(len(arr_2[tmp])):
                if arr_2[tmp][idx] == 1:
                    stack.append(idx)

    return visited


def BFS(start_node):
    visited = []
    queue = [start_node]

    # 선입선출
    while queue:
        # 현재 바라보는 노드(tmp): 큐의 맨 앞
        # 중복을 피해서 tmp를 방문 기록
        # tmp랑 '연결이 된 노드들'을 큐에 더해줘요
        # 큐을 다시 꺼내가면서 큐이 다 빌때까지 순회를 해요.
        tmp = queue.pop(0)
        if tmp not in visited:
            visited.append(tmp)

            for idx in range(len(arr_2[tmp])):
                if arr_2[tmp][idx] == 1:
                    queue.append(idx)

    return visited


# 이진 트리
# 1 2 1 3 2 4 ...
tree = [1, 2, 1, 3, 2, 4, 2, 5, 3, 6, 3, 7, 4, 8]
N = len(tree)

'''
< 그래프 표현하기 >
1. 2차원 리스트 [[1, 2], [1, 3], [2, 4], ...]
2. 딕셔너리     {1: [2, 3], 2: [4, 5], 3: [6, 7], ...}
3. 2차원 인접리스트 
'''

# 2차원 리스트
lst = [[] for _ in range(8+1)]
for i in range(0, N, 2):
    lst[tree[i]].append(tree[i+1])


# 딕셔너리
my_dict = {}
for i in range(N):
    if i % 2 == 0:
        my_dict[tree[i]] = []

for j in range(N):
    if j % 2 == 1:
        my_dict[tree[j-1]].append(tree[j])

# 2차원 인접리스트
arr_2 = [[0] * 9 for _ in range(9)]

for i in range(0, N, 2):
    arr_2[tree[i]][tree[i+1]] = 1


print(DFS(1))
print(BFS(1))
```







# 능숙도 1번

![image-20220407014006407](%EC%84%A4%EB%AA%85.assets/image-20220407014006407.png)

``` python
def BFS(si, sj):
    distance_mat = [[0] * (4) for _ in range(4)]
    visited = []
    queue = [[si, sj]]

    # 선입선출
    while queue:
        # 현재 바라보는 좌표([ti, tj]): 큐의 맨 앞
        # 중복을 피해서 좌표를 방문 기록
        # tmp랑 '연결이 된 좌표들'을 큐에 더해줘요
        # 큐을 다시 꺼내가면서 큐이 다 빌때까지 순회를 해요.
        ti, tj = queue.pop(0)
        if [ti, tj] not in visited:
            visited.append([ti, tj])

            for d in range(4):
                ni = ti + di[d]
                nj = tj + dj[d]
                if 0 <= ni < 4 and 0 <= nj < 4 and [ni, nj] not in visited:
                    queue.append([ni, nj])
                    distance_mat[ni][nj] = distance_mat[ti][tj] + 1

    return distance_mat


matrix = [[0] * (4) for _ in range(4)]

# 델타 - 상하좌우
di = [-1, 1, 0, 0]
dj = [0, 0, -1, 1]

for row in BFS(2, 3):
    print(row)
```





## 2. 

![image-20220407014502858](%EC%84%A4%EB%AA%85.assets/image-20220407014502858.png)

```python
import sys


sys.stdin = open('pracitce.txt')

# 인풋받기
N = int(input())
matrix = [list(map(int, input().split())) for _ in range(N)]

# 시작점들 찾아주기
starts = []
for i in range(N):
    for j in range(N):
        if matrix[i][j] == 1:
            starts.append([i, j])

# 델타 - 상하좌우
di = [-1, 1, 0, 0]
dj = [0, 0, -1, 1]

# BFS
distance_mat = [[100] * (N) for _ in range(N)]

# 선입선출
for start in starts:
    visited = []
    queue = [[start[0], start[1]]]
    distance_mat[start[0]][start[1]] = 1

    while queue:
        # 현재 바라보는 좌표([ti, tj]): 큐의 맨 앞
        # 중복을 피해서 좌표를 방문 기록
        # tmp랑 '연결이 된 좌표들'을 큐에 더해줘요
        # 큐을 다시 꺼내가면서 큐이 다 빌 때까지 순회를 해요.
        [ti, tj] = queue.pop(0)
        if [ti, tj] not in visited:
            visited.append([ti, tj])

            for d in range(4):
                ni = ti + di[d]
                nj = tj + dj[d]
                if 0 <= ni < 4 and 0 <= nj < 4 and [ni, nj] not in visited:
                    queue.append([ni, nj])

                    if distance_mat[ni][nj] > distance_mat[ti][tj] + 1:
                        distance_mat[ni][nj] = distance_mat[ti][tj] + 1

for row in distance_mat:
    print(row)
```





## 3. 

```python
import sys


sys.stdin = open('pracitce.txt')

# 인풋받기
N = int(input())
matrix = [list(map(int, input().split())) for _ in range(N)]

# 시작점들 찾아주기
starts = []
for i in range(N):
    for j in range(N):
        if matrix[i][j] == 1:
            starts.append([i, j])

# 델타 - 상하좌우
di = [-1, 1, 0, 0]
dj = [0, 0, -1, 1]

# BFS
distance_mat = [[100] * (N) for _ in range(N)]

# 선입선출
for start in starts:
    visited = []
    queue = [[start[0], start[1]]]
    distance_mat[start[0]][start[1]] = 1

    while queue:
        # 현재 바라보는 좌표([ti, tj]): 큐의 맨 앞
        # 중복을 피해서 좌표를 방문 기록
        # tmp랑 '연결이 된 좌표들'을 큐에 더해줘요
        # 큐을 다시 꺼내가면서 큐이 다 빌 때까지 순회를 해요.
        [ti, tj] = queue.pop(0)
        if [ti, tj] not in visited:
            visited.append([ti, tj])

            for d in range(4):
                ni = ti + di[d]
                nj = tj + dj[d]
                if 0 <= ni < 4 and 0 <= nj < 4 and [ni, nj] not in visited:
                    queue.append([ni, nj])

                    if distance_mat[ni][nj] > distance_mat[ti][tj] + 1:
                        distance_mat[ni][nj] = distance_mat[ti][tj] + 1

for row in distance_mat:
    print(row)
```





## 4

```python
import sys


sys.stdin = open('pracitce.txt')

def BFS(si, sj):
    global matrix

    visited = []
    queue = [[si, sj]]

    while queue:
        [ti, tj] = queue.pop(0)
        if [ti, tj] not in visited:
            visited.append([ti, tj])
            matrix[ti][tj] = 0
            for d in range(4):
                ni = ti + di[d]
                nj = tj + dj[d]
                if 0 <= ni < N and 0 <= nj < N and [ni, nj] not in visited and matrix[ni][nj] == 1:
                    queue.append([ni, nj])


N = int(input())
matrix = [list(map(int, input().split())) for _ in range(N)]

# 델타 상하좌우
di = [-1, 1, 0, 0]
dj = [0, 0, -1, 1]

cnt = 0
for i in range(N):
    for j in range(N):
        if matrix[i][j] == 1:
            BFS(i, j)
            cnt += 1

print(cnt)
```







## 수영장

``` python
import sys


sys.stdin = open('Swiming_pool.txt')

def DFS(mon, total):
    global result

    if mon > 12:
        if total < result:
            result = total

    else:
        DFS(mon+1, total + plan[mon-1] * day)
        DFS(mon+1, total + month)
        DFS(mon+3, total + month3)

    return result

T = int(input())
for tc in range(1, T+1):
    day, month, month3, year = map(int, input().split())
    plan = list(map(int, input().split()))

    result = 100000

    result = DFS(1, 0)

    if result > year:
        result = year

    print(f"#{tc} {result}")
```

