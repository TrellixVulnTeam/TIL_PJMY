# 큐 (원형큐의 개념, 누가 움직이는지, 포이늩는 마지막까지 이동했을때 add큐, delete큐를 했을때 어떻게되는지?)

* front, rear로 기억하기 (한글말고)
* enQueue/AddQ
* deQueue/DeleteQ

![image-20220225123827197](C:%5CUsers%5Cstar3%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220225123827197.png)





* 다른 것 보다 isEmpty() isFull() 은 알아야함

![image-20220225123907527](C:%5CUsers%5Cstar3%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220225123907527.png)

* 그림 설명![image-20220225124035431](0225_%ED%81%90.assets/image-20220225124035431.png)

- add를 하면 rear에 삽입이 되고
- delete를 하면 front가 움직임

![image-20220225124127470](0225_%ED%81%90.assets/image-20220225124127470.png)



* 대략적인 표현 = adt

![image-20220225124249785](0225_%ED%81%90.assets/image-20220225124249785.png)



* rear가 size -1 이면 full이다

![image-20220225124526635](0225_%ED%81%90.assets/image-20220225124526635.png)



![image-20220225124505133](0225_%ED%81%90.assets/image-20220225124505133.png)

* 큐가 꽉차있지 않음에도 full로 나올수가 있어서 (rear와 front가 같아서..)

  원형보완위해 원형큐가 생겨남



## 원형큐

![image-20220225125056739](0225_%ED%81%90.assets/image-20220225125056739.png)



여기서,

![image-20220225124826119](0225_%ED%81%90.assets/image-20220225124826119.png)



* 머리 꼬리 둘다 같은 지점을 가르키고 있으면 add큐가 안됨 -> 해결위해서 원형큐를만들었더니 둘다 같아도 add큐가 정상적으로됨 

* 하지만 문제가있다. ![image-20220225125152247](0225_%ED%81%90.assets/image-20220225125152247.png)

* isfull() isempty() 둘다 체크할 때 머리 == 꼬리로 체크하게 됨

  * 이 문제는 변수를 새로 하나 설정해서 사용하면 해결된다

  ![image-20220225125414477](0225_%ED%81%90.assets/image-20220225125414477.png)





* 꼭 이렇게 안해도됨. 걍 구분 쉽게하려고 쓰는 방법임

![image-20220225125545968](0225_%ED%81%90.assets/image-20220225125545968.png)



* 구현 안중요함





* 시험문제가 나온다면 % 가 나올것같음 (사이즈안에서 계속 돌게하기위한 것)

![image-20220225125720166](0225_%ED%81%90.assets/image-20220225125720166.png)

* DEQ

![image-20220225130322482](0225_%ED%81%90.assets/image-20220225130322482.png)



덱은 큐의  양끝에서 삽입 삭제가 일어남

덱은 그냥 프런트에 넣어 하면 넣어줌



![image-20220225130558727](0225_%ED%81%90.assets/image-20220225130558727.png)





## 우선순위큐(임의의 위치에서 요소를 꺼낼 수 있음.만 알면됨)

우선순위에 따라서 어떤 위치에서든 요소를 바로 꺼낼 수 있음

heap이라는 자료구조를 사용해서 구현을 한다.정도





## 정리

선형큐 : 머리 꼬리 나뉘어져있고 꼬리에 집어넣고, 머리에서 빼냄

원형큐 : 큐랑 똑같은데 첫번째와 끝이 연결되어있고 %가 포인트

덱 : 머리 꼬리 다 아이템 넣고 뺄수 있음

우선순위 큐: 우선순위에 따라 임의 위치에서 요소 꺼낼 수 있고 heap으로 구현할 수 있다.





비효율적

![image-20220225132415223](0225_%ED%81%90.assets/image-20220225132415223.png)



![image-20220225132424942](0225_%ED%81%90.assets/image-20220225132424942.png)





큐내장사용

![image-20220225132713418](0225_%ED%81%90.assets/image-20220225132713418.png)

* 여러갱의 프로그램에서 큐를 사용한다면? -말티스레딩을위해만들어진개념

![image-20220225133112945](0225_%ED%81%90.assets/image-20220225133112945.png)

 

![image-20220225133222614](0225_%ED%81%90.assets/image-20220225133222614.png)

여기 괄호안에숫자넣으면 그숫자보다크게 큐넣으면망함

작게넣기

그게아니면아ㅏ예안넣으면알아서늘리고해줌

![image-20220225133207852](0225_%ED%81%90.assets/image-20220225133207852.png)







## DFS- stack / BFS - 큐 (큐 상태 변화꼭 해보기/ 코드 구현은 장고 끝나고 다시함..)

![image-20220225134306631](0225_%ED%81%90.assets/image-20220225134306631.png)

* A를 큐에넣고 A를 꺼내면서 A가 갈 수 잇는 애 다 넣어 
* B를 큐에넣고 B를 꺼내면서 B가 갈 수 있는 애 다 넣어
* C~:없으면 그 다음것 

![image-20220225134626007](0225_%ED%81%90.assets/image-20220225134626007.png)

중요한것 : 큐를 그려놓고 큐의 상태변화를 꼭 해보기

![image-20220225134953358](0225_%ED%81%90.assets/image-20220225134953358.png)

## 참고

주소는 다음연결노드의 주소 (내다음노드가어디에잇는지

노드가연결된거 -연결리스트

![image-20220225133427134](0225_%ED%81%90.assets/image-20220225133427134.png)





