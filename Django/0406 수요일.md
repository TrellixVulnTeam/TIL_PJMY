# 0406 수요일 복습

![image-20220406123645179](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406123645179.png)이렇게 3가지로 정리할 것 

> model을 쓰는 이유? 사용자의 인풋을 받아서 db에 저장하려고



> modelform : 재사용성이 높아짐





## django model (웹 어플리케이션에서 데이터를 구조화하고 조작하기 위한 도구)

* model을 통해서 데이터베이스의 구조, 장고의 클래스를 정의했었다.

* `중요 ` model하나가 테이블 하나에 매핑됨
* model을 통해서 레이아웃을 짜고, model을 기반으로 db를 생성함
* DB : 체계화된 데이터의 모임
* 쿼리 : 데이터를 조회하기 위한 명령어
* 장고를 쓸 때는 sql을 직접 사용하지 않고 orm을 통해서 파이썬 문법으로 db와 소통했다.





> 데이터베이스의 기본 구조

* 스키마 : 데이터베이스의 자료의 구조





> orm

* orm : 객체 지향 매핑 :
  * 객체지향언어을 사용해서 호환되지 않은 데이터를 변환하는 프로그래밍 기법
  * = 파이썬을 사용해서 호환되지 않는 시스템 django와 sql간의 원활한 데이터 변환 프로그래밍 기술 
* django는 내장 orm을 사용함





> django orm

데이터베이스와 웹어플리케이션 소통을 sql로 할 수 없기 때문에 파이썬을 사용하고 orm이 sql로 해석을 하고 돌아오는 sql명령문을 파이썬 형태로 만들어준다.

![image-20220406125458371](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406125458371.png)

* 요청을 보냄 queryset API : queryset API문법에 근거하여 python 객체지향적 표현으로 요청을 보냈다.
* 응답을 줌 object, queryset으로 줬음 `이거 시험에 나왔었는데.. ㅎ`
  * 단일 객체
  * 단일 객체가아니라면 queryset 데이터 목록으로 줌





> orm 의 장점과 단점 `생산성 때문에 씀!`

장점 : sql을 잘 알기 못해도 db 조작이 가능하고, 객체 지향적 접근으로 높은 생산성

단점 : orm으로 완전한 서비스를 구현하기 힘들다.

-----> 현대 웹 프레임워크의 요점은 웹 개발의 생산성이 주요 포인트여서 사용하는 것





## orm의 사용이유 : DB를 객체(object)로 조작하기 위해 사용하는 것





`다시 model로 돌아와서`

## model (여기서 중요한 것은 코드를 어떻게 작성했냐 기억해내)

### models.py에 작성

![image-20220406125853354](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406125853354.png)

* models.py에 클래스 형태로 작성
* `models.Model`이라고 상속을 받아 서브클래스로 표현했다.

  * models모듈에 Model이라는 클래스가 있었다.
  * 예전에 장고 github에 들어가서 Model이 어떻게 되어있는지 살펴봤었음
  * model의 역할을 하는 부모 클래스라고 생각하면됨
  * 우리는 필드만 작성하면 됨
* 우리는 제목, 내용이라는 필드를 작성함, 필드는 각 데이터베이스의 열에 매핑
* id필드는 장고가 알아서 작성해주기 때문에 작성하지 않아도 됐다.
  * ![image-20220406130222250](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406130222250.png)models 모듈안에 Model필드로 존재하는 CharField, TextField가 있었음

  * 문자열 필드

    * CharField : 길이 제한 있는 text / max_length 필수 속성
    * TextField : 길이 제한 없는 text






## migrations : django가 model에 생긴 변화를 반영하는 방법

![image-20220406130656849](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406130656849.png)

* 필수 명령어 2가지
  * `makemigrations`로 설계도를 만들고 `migrate`로 db에 반영
  * migrate이후 모델과 db의 스키마가 동기화를 이뤘다고 보면 됨

![image-20220406131530231](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406131530231.png)

* 곁다리
  * sqlmirate : orm을 통해 sql 구문이 어떻게 사용되었는지 볼 수 있음
  * showmigrations : 마이그레이션 파일들이 migrate 됐는지 안됐는지

![image-20220406131614859](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406131614859.png)





> $ python manage.py makemigrations

![image-20220406131856589](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406131856589.png)



* migrations/0001_initial.py 는 이렇게 생김

![image-20220406131937222](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406131937222.png)

* 데이터베이스 입장에서는 이 설계도를 이해할 수 없어서 orm이 변경해주는 것이고
* 우리는 이 설계도에 수정을 가할 필요가 없다





> $ python manage.py migrate

![image-20220406132102375](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406132102375.png)

* 이 명령어로 db에 실제 table이 생성됨





> sqlmigrate

![image-20220406132148088](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406132148088.png)

![image-20220406132206160](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406132206160.png)





> showmigrations

![image-20220406132226207](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406132226207.png)

`[X]` 마이그래이션됨

`[ ]` 마이그래이션 안됨

![image-20220406132314327](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406132314327.png)

* 장고를 실행하는데 있어서 우리가 만든 앱 말고 기본 앱이 존재 한다.
  * project> settings.py> `INSTALLED_APPS` 에 기본앱이 존재함

![image-20220406132359271](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406132359271.png)





> model을 수정하자 (작성시간, 수정시간)을 추가하자

![image-20220406132512948](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406132512948.png)

* auto_now_add , auto_now 시험나옴 ㅋ
* DateTimeField

* 수정하고 나서, makemigrations, migrate





> 왜 그냥 수정이 안되지?!

![image-20220406133349081](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406133349081.png)

* 장고입장에서는 이미 테이블이 존재하는데, 열을 붙인다면, 
  기존 데이터는 어떻게 하지? 아래처럼하면 기본값으로 입력됨

![image-20220406133310773](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406133310773.png)

![image-20220406133855968](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406133855968.png)





> 그럼 두번 째 설계도는 어떻게 될까 ? (변경사항 수정된)

dependencies에 첫번째 설계도가 들어있음

![image-20220406134125713](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406134125713.png)





> migration 3단계

![image-20220406134404982](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406134404982.png)





cf) 동그라미는 객체의 출력 표현을 바꾸는 정도이지, 변경사항은 아님 

![image-20220406134428111](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406134428111.png)







## (중요) Database API (DB를 조작하기 위한 도구)

![image-20220406170206110](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406170206110.png)

* 모델을 만들면 자연스럽게 매니저가 따라 붙음

![image-20220406170228495](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406170228495.png)



* 

![image-20220406170357872](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406170357872.png)







## CRUD

* 조회
  * [] : 대괄호여서 리스트를 쓰듯이 조작하면 된다. 이터러블한 객체로 인덱싱, 슬라이싱 가능

![image-20220406170622515](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406170622515.png)



### create

> create 3가지 방법

1. 첫번째 방법

![image-20220406170917422](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406170917422.png)



2. 두번째 방법

![image-20220406170942689](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406170942689.png)



3. 애초에 인스턴스를 생성하지 않고, 쿼리셋api 중에 create api를 사용함

`save 과정이 포함되어 있음`

![image-20220406171053900](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406171053900.png)



> create 관련 메서드 

* save하지 않으면 객체의 id값은 존재하지 않는다.

![image-20220406171138775](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406171138775.png)



* str : 출력

![image-20220406171215227](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406171215227.png)







### read

* 새로운 쿼리셋을 받는 것 : all / 쿼리셋을 주지 않음 : get (단일 객체 조회)

![image-20220406171312737](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406171312737.png)



* get()은 쿼리셋을 주지 않고 단일 객체를 조회한다. 

![image-20220406171430942](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406171430942.png)



* filter()  / get과는 다르게 쿼리셋을 반환함, 반환이 없어도 오류가 나지 않음

![image-20220406171549081](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406171549081.png)





### update

* 조회를 먼저하고 저장을 꼭 해야 한다.

![image-20220406171847215](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406171847215.png)





### delete

* 조회를 해서 저장을 함. 

![image-20220406171934641](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406171934641.png)





### field lookups : 조회 시 특정 조건을 지정

* pk__gk = 2 : pk가 2보다 큰 거만 조회하겠다
* content__contains='ja' : ja가 포함된 거만 조회하겠다

![image-20220406172118203](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406172118203.png)



## VIEW함수 

![image-20220406173110135](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406173110135.png)

* view에서 쿼리셋을 조회하고, 그걸 context에 키 : 벨류 형태로 받음
* render에 3번째 인자로 넘겨주면 사용할 수 있음



`articles/index.html`

### DTL

`{{  }}` : 변수

`{%  %}` : 태그

![image-20220406173736091](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406173736091.png)



* 2번째 방식을 택한 이유 : 유효성 검사를 위해서

![image-20220406173823774](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406173823774.png)

![image-20220406173846948](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406173846948.png)





* request에서 요청
  * request.POST까지만 하면 딕셔너리 형태여서 get을 사용해서 특정 값을 가지고 와야함.
  * title, content는 model에서 온게 아니라 input의 name값에서 온 것 

![image-20220406173927016](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406173927016.png)

![image-20220406174030994](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406174030994.png)





* create 함수

![image-20220406205145517](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406205145517.png)







----

# 오후 라이브 수업

meta 클래스 : 클래스안에 이너 클래스를 넣어서, 

model, fields를 꼭 넣어줘야함

주의할 점 : 간혹 fields에 all을 넣고 exclude를 동시에 넣으면 안됨.

![image-20220406163706173](0406%20%EC%88%98%EC%9A%94%EC%9D%BC.assets/image-20220406163706173.png)



쭉 입력하게끔 

