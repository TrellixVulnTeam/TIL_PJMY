

# 2016 수 오후 (보충)

![image-20220216183942773](2016%20%EC%88%98%20%EC%98%A4%ED%9B%84%20(%EB%B3%B4%EC%B6%A9).assets/image-20220216183942773.png)

kmp는 현업에서 안써서, 코테에 필요없음, 비트연산 몰라도 삼성b형통과됨

---

----

* 달팽이 문제.. 
* 버블 sort/선택sort

![image-20220216184051877](2016%20%EC%88%98%20%EC%98%A4%ED%9B%84%20(%EB%B3%B4%EC%B6%A9).assets/image-20220216184051877.png)

---

![image-20220216184547641](2016%20%EC%88%98%20%EC%98%A4%ED%9B%84%20(%EB%B3%B4%EC%B6%A9).assets/image-20220216184547641.png)

월요일 : 평가 과목평가 

1,2, 3

1. 구간 합 구할 때 max, sum, min 내장함수 금지
2. 델타 어쩌구 direct배열
3. 비밀...ㅎ 위에 있음 (서술형) - 바이너리 서치..

어떤 알고리즘을 쓰면 이알고리즘을 왜쓰는건지 설명할 수 있어야





## IM 시험

![image-20220216184639935](2016%20%EC%88%98%20%EC%98%A4%ED%9B%84%20(%EB%B3%B4%EC%B6%A9).assets/image-20220216184639935.png)

---

---

![image-20220216184757125](2016%20%EC%88%98%20%EC%98%A4%ED%9B%84%20(%EB%B3%B4%EC%B6%A9).assets/image-20220216184757125.png)



# GNS

![image-20220216184935162](2016%20%EC%88%98%20%EC%98%A4%ED%9B%84%20(%EB%B3%B4%EC%B6%A9).assets/image-20220216184935162.png)

---

# sliding window 알고리즘, two pointer 알고리즘 (이게 대기업 코테)

![image-20220216190725656](2016%20%EC%88%98%20%EC%98%A4%ED%9B%84%20(%EB%B3%B4%EC%B6%A9).assets/image-20220216190725656.png)



----

## 1번 문제 n^2 가 아닌 n의 시간 복잡도로 풀 수 있음.

* 과거에 풀은 방식

![image-20220216191637783](2016%20%EC%88%98%20%EC%98%A4%ED%9B%84%20(%EB%B3%B4%EC%B6%A9).assets/image-20220216191637783.png)



* dat로 풀은 방식

![image-20220216191123825](2016%20%EC%88%98%20%EC%98%A4%ED%9B%84%20(%EB%B3%B4%EC%B6%A9).assets/image-20220216191123825.png)

a의 값들을 b에 있는지 탐색하는건데 

9 * 6번 탐색하는게 아니라, 9 + 6 = 15번으로 같은 결과를 출력 할 수 있다.



1. 버켓이라는 10칸짜리 배열을 만듦

2. 처음에 다 0으로 초기화

3. for문을 사용해서 a배열에 해당하는 인덱스에 1을 넣음 --> 

4. 버켓이랑 b를 돌면서, 1이면 o출력 0이면 x출력!

   ![image-20220216191812026](2016%20%EC%88%98%20%EC%98%A4%ED%9B%84%20(%EB%B3%B4%EC%B6%A9).assets/image-20220216191812026.png)

   ``` python
   a=[4,9,1,4,4,2]
   b=[1,3,4,2,5,6,7,8,9]   # 9* 6번 탐색    # 총 15번 탐색으로 같은 결과 출력
      O X O O X X X X O
   #Q. b 배열 안의 값이 a 배열 안에 있으면 O 출력 없으면 X 출력
   
   
   for i in range(len(b)):
       flag=0
       for j in range(len(a)):
           if a[j] == b[i]:
               flag = 1
               break
       if flag == 1:
           print('O',end=' ')
       else:
           print('X',end=' ')
   
   print()
   print('----')
   
   bucket = [0]*10
   for i in range (len(a)):
       index=a[i]
       bucket[index]=1
   
   for i in range (len(b)):
       if bucket[b[i]] == 1:
           print('O',end=' ')
       else:
           print('X',end=' ')
   ```

   

---





## 2번 문제 알파벳 문제

![image-20220216191943649](2016%20%EC%88%98%20%EC%98%A4%ED%9B%84%20(%EB%B3%B4%EC%B6%A9).assets/image-20220216191943649.png)



1. 이중 for문 돌면서 인덱스를 플러스 1
2. 

![image-20220216192227547](2016%20%EC%88%98%20%EC%98%A4%ED%9B%84%20(%EB%B3%B4%EC%B6%A9).assets/image-20220216192227547.png)

3. A를 버킷의 값만큼 출력, ....

200으로 한 이유는 아스키 코드를 넉넉히 저장하기 위해서 

만약에 0에 저장하고 싶으면 -'A' 을 해주면 됨 (지금 당장은 안해도됨)



```python
arr = [["A","B","C"],["A","G","H"],["H","I","J"],["K","A","B"],["A","B","C"]]

dat=[0]*200

for row in range(5):
    for col in range(3):
        dat[ord(arr[row][col])] += 1

for i in range(len(dat)):
    if dat[i] >= 1:
        print(chr(i)*dat[i], end='')
```



----

# 달팽이

``` python
test_case=int(input())
for tc in range(test_case):
    n=int(input())
    arr=[[0 for _ in range(n)] for _ in range(n)]
    cnt=1
    sw=1
    row=0
    col=-1
    while n>0:
        for _ in range(n):
            col+=sw
            arr[row][col]=cnt
            cnt+=1
        n-=1
        for _ in range(n):
            row+=sw
            arr[row][col]=cnt
            cnt+=1
        sw*=-1

debug=1
```



----

``` python

def sum(y,x):
    z=y+x
    z+=1
    return z
a=10
b=20
b=30
b=40
b=50
b=60
ret=sum(a,b)
print(ret)
```

파이참 디버깅 단축키 입니다.
Ctrl + F8 : Toggle breakpoint
F8 : Step over
F7 : Step into
F9 : resume (다음 break point까지 실행)
Shift + F8 : Step out (함수에서 빠져 나오기)
최민호교수 님이 모두에게:    오후 8:18



----

![image-20220216203306038](2016%20%EC%88%98%20%EC%98%A4%ED%9B%84%20(%EB%B3%B4%EC%B6%A9).assets/image-20220216203306038.png)

재귀, 중복순열, 순열, 조합, 중복조합 - 재귀를 가지고 사용한다.

---



백준 > 문제 > 알고리즘 분류 > 시뮬레이션 : 정답 비율 높은 것 부터.





3, 4dlqfur

![image-20220216203655806](2016%20%EC%88%98%20%EC%98%A4%ED%9B%84%20(%EB%B3%B4%EC%B6%A9).assets/image-20220216203655806.png)





![image-20220216203709462](2016%20%EC%88%98%20%EC%98%A4%ED%9B%84%20(%EB%B3%B4%EC%B6%A9).assets/image-20220216203709462.png)

---



# 패턴찾기

![image-20220216205030138](2016%20%EC%88%98%20%EC%98%A4%ED%9B%84%20(%EB%B3%B4%EC%B6%A9).assets/image-20220216205030138.png)

![image-20220216205129567](2016%20%EC%88%98%20%EC%98%A4%ED%9B%84%20(%EB%B3%B4%EC%B6%A9).assets/image-20220216205129567.png)

![image-20220216212630933](2016%20%EC%88%98%20%EC%98%A4%ED%9B%84%20(%EB%B3%B4%EC%B6%A9).assets/image-20220216212630933.png)

![image-20220216231920286](2016%20%EC%88%98%20%EC%98%A4%ED%9B%84%20(%EB%B3%B4%EC%B6%A9).assets/image-20220216231920286.png)