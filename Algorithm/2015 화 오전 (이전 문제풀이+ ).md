# 2015 화 오전 (이전 문제풀이+ )

* 부분집합 (비트연산자보다 속도가 빠름 : for문)

![image-20220215094917311](2015%20%ED%99%94%20%EC%98%A4%EC%A0%84%20(%EC%9D%B4%EC%A0%84%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4+%20).assets/image-20220215094917311.png)

![image-20220215095031138](2015%20%ED%99%94%20%EC%98%A4%EC%A0%84%20(%EC%9D%B4%EC%A0%84%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4+%20).assets/image-20220215095031138.png)



---

* 달팽이 : 델타이용해서 방향 바꾸기, 언제 바뀔 것인지, 방향을 정하기 (반드시알기.....)

``` python
T = int(input())


for tc in range(1, T + 1):
    N = int(input())
    matrix = [[0]*N for _ in range(N)] #행렬만들어줌
    num = 1
    d_col = [1,0,-1,0] #열  도는 방향 우, 하, 좌, 상 순으로 돌아감
    d_row = [0,1,0,-1] #행
    direction = 0 #우, 하, 좌, 상으로 값주기
    r = 0
    c = 0

    while num <= N*N: #num이 N*N까지 넣어준다.
        matrix[r][c] = num #처음에 1부터시작
        num += 1
        #만약 행,열이 N과 같아지거나 칸에 숫자가 이미 있으면 방향을 바꾼다.
        if r+d_row[direction] == N or c+d_col[direction] == N or matrix[r+d_row[direction]][c+d_col[direction]]:
            direction = (direction+1) % 4   #방향은 우하좌상으로 반복하므로 4의 나머지
            r = r + d_row[direction]    #방향이 맞으면 한칸씩 전진
            c = c + d_col[direction]
        else:
            r = r+d_row[direction]
            c = c+d_col[direction]
    print(f'#{tc}') 
    for i in range(len(matrix)):
        for j in range(len(matrix[i])):
            print(matrix[i][j], end = ' ')
        print()
```

![image-20220215095925088](2015%20%ED%99%94%20%EC%98%A4%EC%A0%84%20(%EC%9D%B4%EC%A0%84%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4+%20).assets/image-20220215095925088.png)

---



# 오늘자 홈워크 

4836. [파이썬 S/W 문제해결 기본] 2일차 - 색칠하기

* 메모리 초과될 때 이렇게 풀기 

https://swexpertacademy.com/main/learn/course/lectureProblemViewer.do![image-20220215150831679](2015%20%ED%99%94%20%EC%98%A4%EC%A0%84%20(%EC%9D%B4%EC%A0%84%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4+%20).assets/image-20220215150831679.png)

n은 각각 종이하나씩이고

출력하면 이렇게 나온다.

![image-20220215150903224](2015%20%ED%99%94%20%EC%98%A4%EC%A0%84%20(%EC%9D%B4%EC%A0%84%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4+%20).assets/image-20220215150903224.png)

r1, c1, r2, c2, color 이렇게 가독성을 높여줌.

![image-20220215151731698](2015%20%ED%99%94%20%EC%98%A4%EC%A0%84%20(%EC%9D%B4%EC%A0%84%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4+%20).assets/image-20220215151731698.png)

![image-20220215151822749](2015%20%ED%99%94%20%EC%98%A4%EC%A0%84%20(%EC%9D%B4%EC%A0%84%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4+%20).assets/image-20220215151822749.png)

![image-20220215151900174](2015%20%ED%99%94%20%EC%98%A4%EC%A0%84%20(%EC%9D%B4%EC%A0%84%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4+%20).assets/image-20220215151900174.png)



```python
'''
4836. [파이썬 S/W 문제해결 기본] 2일차 - 색칠하기
'''
import sys

sys.stdin = open("input.txt")

T = int(input())
for tc in range(1, T + 1):
    n = int(input())  # 종이 장수
    data_set = [list(map(int, input().split())) for _ in range(n)]

    # 미리 set을 정의
    red = set()
    blue = set()

    for data in data_set:
        r1, c1, r2, c2, color = data

        # 각각의 범위에서 좌표를 구해서, set에 담는거죠
        for r in range(r1, r2 + 1):
            for c in range(c1, c2 + 1):  # 범위는 항상 조심!
                if color == 1:
                    red.add((r, c))
                else:
                    blue.add((r, c))

    rlt = len(red & blue)  # red.intersection(blue)
    print(f"#{tc} {rlt}")

"""
    합집합
    red | blue
    red.union(blue)
    
    차집합
    red - blue
    red.difference(blue)
    
    대칭차집합
    red ^ blue
"""
```





---



* 이진탐색 함수로 구현하겠다

![image-20220215153331774](2015%20%ED%99%94%20%EC%98%A4%EC%A0%84%20(%EC%9D%B4%EC%A0%84%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4+%20).assets/image-20220215153331774.png)

함수로빼자 , 몇번을 돌릴지 모르니까 while로 쓰자. start <= end/까지 돌려도됨.

![image-20220215153815722](2015%20%ED%99%94%20%EC%98%A4%EC%A0%84%20(%EC%9D%B4%EC%A0%84%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4+%20).assets/image-20220215153815722.png)

![image-20220215153956024](2015%20%ED%99%94%20%EC%98%A4%EC%A0%84%20(%EC%9D%B4%EC%A0%84%20%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4+%20).assets/image-20220215153956024.png)



``` python
# SWEA 4839 이진탐색
import sys

sys.stdin = open("input.txt")


def binary_search(page, key):
    start = 1
    end = page
    count = 0  # 몇 번만에 찾을지

    while start <= end:
        middle = (start + end) // 2

        if middle == key:
            return count
        elif middle > key:
            end = middle
        else:
            start = middle

        count += 1


T = int(input())
for tc in range(1, T + 1):
    page, a, b = map(int, input().split())
    page_a = binary_search(page, a)
    page_b = binary_search(page, b)

    win = 0
    if page_a < page_b:
        win = "A"
    elif page_a > page_b:
        win = "B"
    print(f"#{tc} {win}")
```



---

4837. [파이썬 S/W 문제해결 기본] 2일차 - 부분집합의 합

* 부분집합의 합

