# 알고리즘 0209 저녁 (완전 검색)

![image-20220209183950171](0209%20%EC%88%98%20%EC%A0%80%EB%85%81%20().assets/image-20220209183950171.png)

![image-20220209184332114](0209%20%EC%88%98%20%EC%A0%80%EB%85%81%20().assets/image-20220209184332114.png)





## 중요) 알고리즘 성능평가 - 빅오 표기법

* 버블은 구현력을 키우는 것임.  -> 나중엔 sort() 로 거의 다 ..!
* 나중에 코테에서는 카운트를 씀



* 시간 복잡도, 공간 복잡도로 나눠서 평가함
  * 삼성 A, IM, 일반적인 기업에서는 시간복잡도
  * 나중에 삼성 B형이나 임베디드는 공간복잡도도 잘 알아야함.



### 시간 복잡도 : 더 빠르게 푸는 것

* 점근적 표기법 = 정확한 계산이 아닌, `대략적인 계산`이다.
* 최악 표기법 : 최악의 수를 집어넣다고 가정함 (엄청나게 큰 수를 집어넣음)
* for문이 있다고 무조건 n이 아니라, 입력받은 수가 있다면 숫자로 보면 될듯
  * 보통 +O(log n)의 값이 생략되어 있음

![image-20220209190800791](0209%20%EC%88%98%20%EC%A0%80%EB%85%81%20().assets/image-20220209190800791.png)

* O(1) O(log n) O(n)
  * 이진트리 탐색
  * 여기서 데이터수 7개 + 통상 더해주는 1개 = 8  log2 8 = 3!

![image-20220209191225109](0209%20%EC%88%98%20%EC%A0%80%EB%85%81%20().assets/image-20220209191225109.png)



![image-20220209185153906](0209%20%EC%88%98%20%EC%A0%80%EB%85%81%20().assets/image-20220209185153906.png)

![image-20220209185428393](0209%20%EC%88%98%20%EC%A0%80%EB%85%81%20().assets/image-20220209185428393.png)





* O(n+3)로 표기 가능. 대략 O(n)

![image-20220209185932247](0209%20%EC%88%98%20%EC%A0%80%EB%85%81%20().assets/image-20220209185932247.png)



* O(n제곱)

![image-20220209190159589](0209%20%EC%88%98%20%EC%A0%80%EB%85%81%20().assets/image-20220209190159589.png)



* O(3n) = O(n)

![image-20220209190338989](0209%20%EC%88%98%20%EC%A0%80%EB%85%81%20().assets/image-20220209190338989.png)



* O(n제곱+n+2) => 최고차항만 고려해서 O(n제곱)의 속도로 봄.

![image-20220209190516588](0209%20%EC%88%98%20%EC%A0%80%EB%85%81%20().assets/image-20220209190516588.png)



* swea : 시간 복잡도(1초걸린다 -> 1억번 반복수행하면,, 이라고 생각하고 계산함)

![image-20220209191459036](0209%20%EC%88%98%20%EC%A0%80%EB%85%81%20().assets/image-20220209191459036.png)

1초가 걸려야 하는데 코드 정답은 나오는데 이중 for문으로 하면 오답나옴.. 왜 맞는데 틀리지? 가 나옴

이것은 시간 초과로 오답이 나오는 것임.

![image-20220209191818097](0209%20%EC%88%98%20%EC%A0%80%EB%85%81%20().assets/image-20220209191818097.png)



### 문제 읽기(제한시간, n값 확인)-> 설계 -> 구현 -> 디버깅



## 중요) 자료구조 알고리즘을 공부하면서 지켜야할 원칙

* 문제 많이 풀어보기
* 반복만이 살길 - 백준 레벨 별로 풀기
* 디버깅 많이 해보기



## 중요) DAT (Direct Address Table 자료구조) for 빠른 검색을 위한 자료구조

* dat (count sort 기본 원리)

* 이진트리 탐색
* 해시



#### dat 자료구조

* 그냥 for문을 돌리면 54번 반복함 O(n제곱) --> dat로 하면 O(n)으로 해결해버림.(15번)

![image-20220209193303412](0209%20%EC%88%98%20%EC%A0%80%EB%85%81%20().assets/image-20220209193303412.png)



* 1.dat에 등록(bucket으로 등록한다)
* 2.b의 값이 있는지 for문을 돌면서 탐색.

![image-20220209193804942](0209%20%EC%88%98%20%EC%A0%80%EB%85%81%20().assets/image-20220209193804942.png)

![image-20220209194031272](0209%20%EC%88%98%20%EC%A0%80%EB%85%81%20().assets/image-20220209194031272.png)

![image-20220209194049514](0209%20%EC%88%98%20%EC%A0%80%EB%85%81%20().assets/image-20220209194049514.png)



## 카운팅 소트

![image-20220209194428797](0209%20%EC%88%98%20%EC%A0%80%EB%85%81%20().assets/image-20220209194428797.png)

n개의 수를 입력받았다고 가정해보자.

![image-20220209194544035](0209%20%EC%88%98%20%EC%A0%80%EB%85%81%20().assets/image-20220209194544035.png)



1. dat 등록

for문을 돌면서 해당되는 곳에체크하기.



2. 누적합 = bucket 계산

![image-20220209194833354](0209%20%EC%88%98%20%EC%A0%80%EB%85%81%20().assets/image-20220209194833354.png)



3. 빈배열을 만들어서 값넣기 낮은 계수부터 누적합이 적혀버림..

![image-20220209195119748](0209%20%EC%88%98%20%EC%A0%80%EB%85%81%20().assets/image-20220209195119748.png)

```python
# n개의 숫자를 입력받은 후 (1~100사이의 숫자를 입력받는다고 가정)
# counting sort 이용해서 출력하기

n=int(input())
a=list(map(int,input().split()))
bucket=[0]*101

# dat 등록
for i in range(n):
    bucket[a[i]]+=1

# 누적합
for i in range(1,len(bucket)):
    bucket[i]+=bucket[i-1]
    #bucket[i]=bucket[i]+bucket[i-1]

# 값넣기

result=[0]*101
for i in range(n):
    index=a[i] #버켓배열의 인덱스
    result[bucket[index]-1]=a[i]# 인덱스에 적혀있는 누적합 -1 한 곳에 값넣기
    bucket[index]-=1 # 누적합에서 1빼기

for i in range(n):
    print(result[i],end=' ')
```





2보다 작은건 7개 (1이 7)

![image-20220209200837910](0209%20%EC%88%98%20%EC%A0%80%EB%85%81%20().assets/image-20220209200837910.png)

